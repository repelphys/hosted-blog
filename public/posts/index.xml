<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on The CollabChain Digest</title>
    <link>/posts/</link>
    <description>Recent content in Posts on The CollabChain Digest</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jan 2025 12:28:01 +0000</lastBuildDate>
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>File Versioning</title>
      <link>/posts/fileversioning/</link>
      <pubDate>Sat, 28 Dec 2024 20:43:13 +0000</pubDate>
      <guid>/posts/fileversioning/</guid>
      <description>&lt;p&gt;Imagine you&amp;rsquo;re in a group setting - working on a collaborative project, where multiple others are editing files and pushing changes. You would naturally want to know:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;who made changes&lt;/li&gt;&#xA;&lt;li&gt;when such changes were made&lt;/li&gt;&#xA;&lt;li&gt;what those changes were.&#xA;You would also want it to be so that no single entity controls the entirety of the data.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;CollabChain uses smart contracts to allow users to:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Add new versions of a file&lt;/li&gt;&#xA;&lt;li&gt;Retrieve the total number of versions for a file&lt;/li&gt;&#xA;&lt;li&gt;Fetch the entire version history of a file + metadata.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;tech-stack&#34;&gt;Tech Stack&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Solidity&lt;/strong&gt;: the programming language required for writing smart contracts on Ethereum&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;IPFS&lt;/strong&gt;: used to store the actual file content. Each file version is represented by its IPFS CID, which is a unique hash that points to the file.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Ethereum&lt;/strong&gt;: the blockchain that contains our smart contract.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;solving-the-problem&#34;&gt;Solving the Problem&lt;/h2&gt;&#xA;&lt;h3 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h3&gt;&#xA;&lt;p&gt;Two key data structures were defined:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Project Management (AuthService)</title>
      <link>/posts/projectmanage/</link>
      <pubDate>Sun, 12 Jan 2025 19:57:06 +0000</pubDate>
      <guid>/posts/projectmanage/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Role-based_access_control&#34;&gt;RBAC (Role-based access control) is the approach of restricting system access to varying degrees of authorized users&lt;/a&gt; - implemented here with three levels:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Owner&lt;/li&gt;&#xA;&lt;li&gt;Editor&lt;/li&gt;&#xA;&lt;li&gt;Viewer&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const projectData = {&#xA;  name: projectName,&#xA;  createdAt: new Date().toISOString(),&#xA;  members: {&#xA;    owner: [username],&#xA;    viewer: [],&#xA;    editor: [],&#xA;  },&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We do this in order to uphold the standard of file-collaboration applications, where certain members will require access to more permissions than others.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Project - Data Synchronisation (AuthService)</title>
      <link>/posts/proj_datasyncing/</link>
      <pubDate>Sat, 11 Jan 2025 15:28:12 +0000</pubDate>
      <guid>/posts/proj_datasyncing/</guid>
      <description>&lt;p&gt;Ensuring that project data remained consistent across all user documents was critical.&#xA;In the situation that project membership changes, additional security measures are implemented:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Update all users who have this project&#xA;const usersSnapshot = await db.collection(&amp;#39;Users&amp;#39;).get();&#xA;const updatePromises = [];&#xA;&#xA;usersSnapshot.forEach((doc) =&amp;gt; {&#xA;  const user = doc.data();&#xA;  if (user.invitedProjects) {&#xA;    const projectIndex = user.invitedProjects.findIndex(&#xA;      (p) =&amp;gt; p.name === invitation.projectName&#xA;    );&#xA;    if (projectIndex !== -1) {&#xA;      updatePromises.push(&#xA;        db.collection(&amp;#39;Users&amp;#39;).doc(doc.id).update({&#xA;          invitedProjects: updatedInvitedProjects,&#xA;        })&#xA;      );&#xA;    }&#xA;  }&#xA;});&#xA;&#xA;await Promise.all(updatePromises);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;We start by fetching users from the aptly titled &lt;code&gt;Users&lt;/code&gt; collection in Firebase.&lt;/li&gt;&#xA;&lt;li&gt;We then check if they have access to the project by searching for the project name in the &lt;code&gt;invitedProjects&lt;/code&gt; array.&lt;/li&gt;&#xA;&lt;li&gt;If the user does have access, then an update operation is added to the &lt;code&gt;updatePromises&lt;/code&gt; array - updating the user&amp;rsquo;s &lt;code&gt;invitedProjects&lt;/code&gt; array with latest data.&lt;/li&gt;&#xA;&lt;li&gt;Lastly, we use &lt;code&gt;Promise.all&lt;/code&gt; to execute all updates in parallel.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Invitation System (AuthService)</title>
      <link>/posts/invitationsystem/</link>
      <pubDate>Sat, 11 Jan 2025 12:59:43 +0000</pubDate>
      <guid>/posts/invitationsystem/</guid>
      <description>&lt;p&gt;Team collaboration is managed through a two-step process.&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-invitation-creation&#34;&gt;1. Invitation creation&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const invitationData = {&#xA;  id: Math.random().toString(36).substr(2, 9),&#xA;  projectName,&#xA;  inviterUid,&#xA;  inviterName: inviter.displayName,&#xA;  inviteeUid: inviteeRecord.uid,&#xA;  role: role,&#xA;  status: &amp;#39;pending&amp;#39;,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-invitation-response-handling&#34;&gt;2. Invitation Response Handling&lt;/h4&gt;&#xA;&lt;p&gt;Upon a user accepting an invitation, the system will respond accordingly by:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Updating the project members list&lt;/li&gt;&#xA;&lt;li&gt;Sychronising the project data across all members in the group&lt;/li&gt;&#xA;&lt;li&gt;Deleting the invitation&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;This is to prevent duplicate invitations from repeatedly appearing, maintaining data integrity.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Frontend</title>
      <link>/posts/frontend/</link>
      <pubDate>Sun, 05 Jan 2025 19:19:35 +0000</pubDate>
      <guid>/posts/frontend/</guid>
      <description>&lt;p&gt;With the frontend, our goal was to provide a seamless user interface for uploading, editing and viewing files.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;&#xA;&lt;p&gt;Tools that we decided on for the frontend included:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;React&lt;/strong&gt;: for building the application.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://firebase.google.com/&#34;&gt;&lt;strong&gt;Firebase&lt;/strong&gt;&lt;/a&gt;: for real-time database, authentication, and file storage.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://ipfs.tech/&#34;&gt;IPFS&lt;/a&gt;&lt;/strong&gt;: for storing file versions.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Ethereum&lt;/strong&gt;: for tracking file version history.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://hardhat.org/&#34;&gt;Hardhat&lt;/a&gt;&lt;/strong&gt;: for Ethereum smart contracts.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://codemirror.net/&#34;&gt;CodeMirror&lt;/a&gt;&lt;/strong&gt;: for the in-browser code editor.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Project Page</title>
      <link>/posts/projectpage/</link>
      <pubDate>Sat, 18 Jan 2025 12:28:01 +0000</pubDate>
      <guid>/posts/projectpage/</guid>
      <description>&lt;p&gt;Project data (including files and members) was fetched from Firebase when the page loaded. This included filtering files based on the userâ€™s role (owner, editor, or viewer).&#xA;To make sure that the interface updated in real-time when files were added/modified, we used Firebase&amp;rsquo;s real-time listeners - storing file metadata (uploader, timestamps) in Firebase for easy retrieval want necessary.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;useEffect(() =&amp;gt; {&#xA;  const fetchData = async () =&amp;gt; {&#xA;    const projectDoc = await getDoc(doc(db, &amp;#39;Projects&amp;#39;, decodedProjectName));&#xA;    if (projectDoc.exists()) {&#xA;      setFiles(projectDoc.data().files || []);&#xA;    }&#xA;  };&#xA;  fetchData();&#xA;}, [decodedProjectName]);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Invitation Handling</title>
      <link>/posts/invitations/</link>
      <pubDate>Tue, 07 Jan 2025 12:22:50 +0000</pubDate>
      <guid>/posts/invitations/</guid>
      <description>&lt;p&gt;We then implemented the logic for handling project invitations. Upon accepting or declining an invite, an API call would be triggered to update the invitation status in Firebase.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const handleInvitationResponse = async (invitationId, accept) =&amp;gt; {&#xA;  try {&#xA;    const res = await axios.post(&amp;#39;/api/respondToInvitation&amp;#39;, {&#xA;      invitationId,&#xA;      uid: auth.currentUser.uid,&#xA;      accept,&#xA;    });&#xA;    if (res.data.Status === &amp;#39;Success&amp;#39;) {&#xA;      await fetchUserData(); // Refresh the data&#xA;      toast.success(accept ? &amp;#39;Invitation accepted&amp;#39; : &amp;#39;Invitation declined&amp;#39;);&#xA;    }&#xA;  } catch (error) {&#xA;    toast.error(error.message);&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We made sure that the interface updated in real-time upon a user&amp;rsquo;s response to an invitation by refetching the user data after each response. We decided on using &lt;code&gt;axios&lt;/code&gt; for API calls due to its built-in error handling and ease of use.&lt;/p&gt;</description>
    </item>
    <item>
      <title>File Upload (Frontend)</title>
      <link>/posts/fileupload/</link>
      <pubDate>Mon, 06 Jan 2025 12:29:27 +0000</pubDate>
      <guid>/posts/fileupload/</guid>
      <description>&lt;p&gt;We made it so that only users with the &lt;code&gt;editor&lt;/code&gt; or &lt;code&gt;owner&lt;/code&gt; role can upload files - stored on IPFS (Interplanetary File System).&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const handleFileUpload = async (event) =&amp;gt; {&#xA;  const file = event.target.files[0];&#xA;  const cid = await uploadToPinata(file);&#xA;  const newFile = {&#xA;    name: file.name,&#xA;    cid: cid,&#xA;    uploadedBy: auth.currentUser.displayName,&#xA;    uploadedAt: new Date().toISOString(),&#xA;  };&#xA;&#xA;  const projectRef = doc(db, &amp;#39;Projects&amp;#39;, decodedProjectName);&#xA;  await updateDoc(projectRef, { files: [...files, newFile] });&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To handle large file uploads that could potentially lead to browser slowdown and crashes, we used chunked uploads and progress indicators.&lt;/p&gt;</description>
    </item>
    <item>
      <title>File Editing and Saving (Frontend)</title>
      <link>/posts/fileediting/</link>
      <pubDate>Mon, 06 Jan 2025 12:26:34 +0000</pubDate>
      <guid>/posts/fileediting/</guid>
      <description>&lt;p&gt;We settled on integrating &lt;a href=&#34;https://codemirror.net/&#34;&gt;CodeMirror&lt;/a&gt; to create a flexible code editor that can support a variety of different langauges (i.e. JavaScript, Markdown, etc.)&#xA;The editor will adjust itself based on the file type, with expected syntax highlighting and auto-completion.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;CodeMirror&#xA;  value={content}&#xA;  extensions={[getLanguageExtension(file.name)]}&#xA;  onChange={(value) =&amp;gt; setContent(value)}&#xA;  readOnly={!isEditing}&#xA;/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We really wanted to make sure that each version of a file was immutable and transparent.&#xA;In order to do this - when a new version of a file is saved, it gets uploaded to &lt;strong&gt;IPFS&lt;/strong&gt; (InterPlanetary File System) and the CID (Content Identifier) is recorded on the &lt;strong&gt;Ethereum blockchain&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dashboard</title>
      <link>/posts/dashboard/</link>
      <pubDate>Tue, 24 Dec 2024 04:14:54 -0800</pubDate>
      <guid>/posts/dashboard/</guid>
      <description>&lt;p&gt;The dashboard is where users can view their projects, invitations, and invited projects. The approach to designing it was:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Fetching the userâ€™s data from Firebase.&#xA;This includes their projects, invitations, and role-based access. We used Firebaseâ€™s &lt;code&gt;getDoc&lt;/code&gt; to retrieve the data and filtered it based on the userâ€™s role (owner, editor, or viewer) to ensure that users would only see the projects that they had access to.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const fetchUserData = async () =&amp;gt; {&#xA;  if (auth.currentUser) {&#xA;    const docRef = doc(db, &amp;#39;Users&amp;#39;, auth.currentUser.uid);&#xA;    const docSnap = await getDoc(docRef);&#xA;    if (docSnap.exists()) {&#xA;      const userData = docSnap.data();&#xA;      setProjects(userData.myProjects || []);&#xA;      setInvitedProjects(userData.invitedProjects || []);&#xA;    }&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;The &lt;code&gt;fetchUserData&lt;/code&gt; function retrieves the userâ€™s projects and invitations from Firebase. It filters projects where the user is the owner and those where theyâ€™ve been invited.&lt;/li&gt;&#xA;&lt;li&gt;Users can create new projects, which are stored in Firebase and linked to their account.&lt;/li&gt;&#xA;&lt;li&gt;Project owners can invite new members by entering their email and assigning a role (viewer or editor).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;react-toastify&lt;/code&gt; is the React library that we decided on using to provide notifications, alerting users for situations such as project creation, invitation responses, and errors.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Advanced Deployment</title>
      <link>/posts/deploymentadvanced/</link>
      <pubDate>Thu, 02 Jan 2025 12:39:02 +0000</pubDate>
      <guid>/posts/deploymentadvanced/</guid>
      <description>&lt;p&gt;&lt;code&gt;Lock.js&lt;/code&gt; utilises &lt;strong&gt;Hardhat Ignition&lt;/strong&gt; to deploy a &lt;code&gt;Lock&lt;/code&gt; contract. This is much more flexible than &lt;code&gt;deploy.js&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const { buildModule } = require(&amp;#34;@nomicfoundation/hardhat-ignition/modules&amp;#34;);&#xA;&#xA;const JAN_1ST_2030 = 1893456000;&#xA;const ONE_GWEI = 1_000_000_000n;&#xA;&#xA;module.exports = buildModule(&amp;#34;LockModule&amp;#34;, (m) =&amp;gt; {&#xA;  const unlockTime = m.getParameter(&amp;#34;unlockTime&amp;#34;, JAN_1ST_2030);&#xA;  const lockedAmount = m.getParameter(&amp;#34;lockedAmount&amp;#34;, ONE_GWEI);&#xA;&#xA;  const lock = m.contract(&amp;#34;Lock&amp;#34;, [unlockTime], {&#xA;    value: lockedAmount,&#xA;  });&#xA;&#xA;  return { lock };&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Hardhat Ignition&lt;/strong&gt;: &lt;code&gt;buildModule&lt;/code&gt; is imported from Hardhat Ignition. This allows us to define a deployment module.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Define constants&lt;/strong&gt;: Two constants are defined:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;JAN_1ST_2030&lt;/code&gt;: A Unix timestamp for January 1st, 2030.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ONE_GWEI&lt;/code&gt;: This represents a single Gwei (a small unit of Ether).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Build module&lt;/strong&gt;: &lt;code&gt;buildModule&lt;/code&gt; defines a deployment module called &lt;code&gt;LockModule&lt;/code&gt; - inside of which contains:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;parameter retrieval (&lt;code&gt;unlockTime&lt;/code&gt; and &lt;code&gt;lockedAmount&lt;/code&gt;) with default values.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Lock&lt;/code&gt; contract is deployed, which will send &lt;code&gt;unlockTime&lt;/code&gt; as a constructor argument and forwards &lt;code&gt;lockedAmount&lt;/code&gt; of Ether with the deployment.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Return the Contract&lt;/strong&gt;: Lastly, the deployed &lt;code&gt;Lock&lt;/code&gt; contract instance is returned.&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Deployment Tech Stack</title>
      <link>/posts/deploymenttechstack/</link>
      <pubDate>Wed, 01 Jan 2025 15:18:55 +0000</pubDate>
      <guid>/posts/deploymenttechstack/</guid>
      <description>&lt;p&gt;The process of deploying smart contracts can be rather frustrating, especially with having to manage complex deployment workflows or deal with multiple environments.&#xA;With the help of Hardhat, this can all be made easier by providing a solid framework of testing, compiling and deploying contracts.&lt;/p&gt;&#xA;&lt;p&gt;We implemented various tools to make the deployment work as intended. Such included:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hardhat.org/&#34;&gt;Hardhat&lt;/a&gt; - dev environment for Ethereum that helps with testing smart contracts&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.ethers.org/v5/&#34;&gt;Ethers.js&lt;/a&gt; -  library for interacting with the Ethereum blockchain&lt;/li&gt;&#xA;&lt;li&gt;Hardhat Ignition - module-based deployment system for Hardhat, used for complex deployment scenarios.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;design-decisions&#34;&gt;Design Decisions&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hardhat Ignition allows for deployments to be defined as modules, which made it easier to reuse deployments.&lt;/li&gt;&#xA;&lt;li&gt;Value Handling: The &lt;code&gt;value&lt;/code&gt; option allows us to send Ether with the deployment - very beneficial for contracts that required an upfront initial balance.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Basic Deployment</title>
      <link>/posts/deploymentbasic/</link>
      <pubDate>Wed, 01 Jan 2025 12:37:06 +0000</pubDate>
      <guid>/posts/deploymentbasic/</guid>
      <description>&lt;p&gt;&lt;code&gt;deploy.js&lt;/code&gt; contains a simple script that deploys our &lt;code&gt;FileVersioning&lt;/code&gt; contract. It&amp;rsquo;s best used for quick deployments.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const hre = require(&amp;#39;hardhat&amp;#39;);&#xA;&#xA;async function main() {&#xA;  // Get the contract factory&#xA;  const FileVersioning = await hre.ethers.getContractFactory(&amp;#39;FileVersioning&amp;#39;);&#xA;  console.log(&amp;#39;Deploying FileVersioning...&amp;#39;);&#xA;&#xA;  // Deploy the contract&#xA;  const fileVersioning = await FileVersioning.deploy();&#xA;  console.log(&amp;#39;Contract deployed to:&amp;#39;, await fileVersioning.getAddress());&#xA;&#xA;  // Wait for 5 block confirmations&#xA;  await fileVersioning.waitForDeployment();&#xA;  console.log(&amp;#39;Contract deployment confirmed&amp;#39;);&#xA;}&#xA;&#xA;// Execute the deployment&#xA;main()&#xA;  .then(() =&amp;gt; process.exit(0))&#xA;  .catch((error) =&amp;gt; {&#xA;    console.error(error);&#xA;    process.exit(1);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;whats-going-on&#34;&gt;Whatâ€™s going on?&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Importing Hardhat&lt;/strong&gt;: First, we import the Hardhat runtime environment (&lt;code&gt;hre&lt;/code&gt;). This provides access to Ethereum and Hardhat-specific functionality.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Get the contract factory&lt;/strong&gt;: &lt;code&gt;hre.ethers.getContractFactory&lt;/code&gt; is used to get an instance of the &lt;code&gt;FileVersioning&lt;/code&gt; contract. To put it simply, it&amp;rsquo;s basically a blueprint for deploying the contract.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Contract deployment&lt;/strong&gt;: &lt;code&gt;deploy()&lt;/code&gt; is called on the contract factory to deploy the contract to the blockchain. A contract instance is then returned.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Wait&lt;/strong&gt;: We must then wait for this deployment to be confirmed by the blockchain (about 5 block confirmations).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Log the Address&lt;/strong&gt;: Finally, we can then log the address of the deployed contract.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;A &lt;code&gt;try-catch&lt;/code&gt; block is used to ensure that any errors during deployment are caught and logged.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Usernames - Data Synchronisation (AuthService)</title>
      <link>/posts/username_datasync/</link>
      <pubDate>Tue, 14 Jan 2025 20:40:43 +0000</pubDate>
      <guid>/posts/username_datasync/</guid>
      <description>&lt;h3 id=&#34;1-username-input-validation&#34;&gt;1. Username Input Validation&lt;/h3&gt;&#xA;&lt;p&gt;On the client side:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function isUsernameValid(username) {&#xA;  return /^[a-zA-Z0-9]+$/.test(username);&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;A regular expression is used to verify that a username only contains alphanumeric characters.&lt;/li&gt;&#xA;&lt;li&gt;If the username is valid, return &lt;code&gt;true&lt;/code&gt;, else return &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;hellip;It&amp;rsquo;s really funny how straightforward using a regular expression is to implement alphanumeric validation.&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-duplicate-username-prevention&#34;&gt;2. Duplicate Username Prevention&lt;/h3&gt;&#xA;&lt;p&gt;We needed to ensure usernames were unique. Seriously, imagine if two users in the same group shared the same username - what a headache.&lt;/p&gt;</description>
    </item>
    <item>
      <title>User Registration Flow (AuthService)</title>
      <link>/posts/userregflow/</link>
      <pubDate>Mon, 13 Jan 2025 12:52:51 +0000</pubDate>
      <guid>/posts/userregflow/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;When a user is done registrating, a client will send their email and password to the &lt;code&gt;/auth/register&lt;/code&gt; folder on Firebase.&lt;/li&gt;&#xA;&lt;li&gt;Firebase will then use this information to create an authentication record.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;app.post(&amp;#39;/auth/register&amp;#39;, async (req, res) =&amp;gt; {&#xA;  const { email, pass } = req.body;&#xA;  &#xA;  try {&#xA;    // Create auth record&#xA;    const userRecord = await auth.createUser({&#xA;      email,&#xA;      password: pass,&#xA;    });&#xA;&#xA;    // Initialize Firestore document&#xA;    await db.collection(&amp;#39;Users&amp;#39;).doc(userRecord.uid).set({&#xA;      displayName: &amp;#39;&amp;#39;,&#xA;      email: userRecord.email,&#xA;      photoURL: &amp;#39;&amp;#39;,&#xA;      myProjects: [],&#xA;      invitedProjects: [],&#xA;      invitations: [],&#xA;      createdAt: admin.firestore.FieldValue.serverTimestamp(),&#xA;    });&#xA;&#xA;    res.status(200).json({&#xA;      Status: &amp;#39;User Created&amp;#39;,&#xA;      User: userRecord&#xA;    });&#xA;  } catch (error) {&#xA;    console.error(&amp;#39;Error creating user:&amp;#39;, error.message);&#xA;    res.status(200).json({ Status: &amp;#39;Error&amp;#39;, message: error.message });&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;Firestore then initialises user document data structure.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{&#xA;  displayName: &amp;#39;&amp;#39;,&#xA;  email: userRecord.email,&#xA;  photoURL: &amp;#39;&amp;#39;,&#xA;  myProjects: [],      // Projects they own&#xA;  invitedProjects: [], // Projects they&amp;#39;re part of&#xA;  invitations: [],     // Pending invites&#xA;  createdAt: timestamp&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>State Management Strategy (Registration)</title>
      <link>/posts/statemanagement/</link>
      <pubDate>Fri, 10 Jan 2025 12:46:46 +0000</pubDate>
      <guid>/posts/statemanagement/</guid>
      <description>&lt;p&gt;We decided on implementing a global user context using React&amp;rsquo;s Context API. This both allowed for &lt;strong&gt;authentication state persistence&lt;/strong&gt; and &lt;strong&gt;data consistency&lt;/strong&gt; - in that we standardized the user object structure throughout the application, making it easier to work with this user data in different components.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;useEffect(() =&amp;gt; {&#xA;  const unsubscribe = onAuthStateChanged(auth, (firebaseUser) =&amp;gt; {&#xA;    if (firebaseUser) {&#xA;      const userData = {&#xA;        uid: firebaseUser.uid,&#xA;        email: firebaseUser.email,&#xA;        displayName: firebaseUser.displayName,&#xA;        photoURL: firebaseUser.photoURL,&#xA;      };&#xA;      setUser(userData);&#xA;    } else {&#xA;      setUser(null);&#xA;    }&#xA;    setLoading(false);&#xA;  });&#xA;&#xA;  return () =&amp;gt; unsubscribe();&#xA;}, []);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Server Initialisation (AuthService)</title>
      <link>/posts/serverinit/</link>
      <pubDate>Sun, 05 Jan 2025 12:51:39 +0000</pubDate>
      <guid>/posts/serverinit/</guid>
      <description>&lt;h3 id=&#34;server-initialisation&#34;&gt;Server Initialisation&lt;/h3&gt;&#xA;&lt;p&gt;The foundation is set by establishing two main systems:&#xA;- Firebase Admin SDK&#xA;- Express.js&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const serviceAccount = JSON.parse(&#xA;  fs.readFileSync(&amp;#39;./config/firebase-adminsdk.json&amp;#39;, &amp;#39;utf8&amp;#39;)&#xA;);&#xA;&#xA;admin.initializeApp({&#xA;  credential: admin.credential.cert(serviceAccount),&#xA;});&#xA;&#xA;const auth = admin.auth();&#xA;const db = admin.firestore();&#xA;&#xA;const app = express();&#xA;app.use(express.json());&#xA;app.use(cors());&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Register and Login Form (Registration)</title>
      <link>/posts/registrationform/</link>
      <pubDate>Fri, 03 Jan 2025 12:44:12 +0000</pubDate>
      <guid>/posts/registrationform/</guid>
      <description>&lt;p&gt;Register.jsx handles the user registration and login forms, manages the user state, as well as communicating with Firebase for authentication.&#xA;UserContext.jsx provides context to manage and save user state.&lt;/p&gt;&#xA;&lt;h3 id=&#34;authentication-form-component&#34;&gt;Authentication form component&lt;/h3&gt;&#xA;&lt;p&gt;One of the first of our design decisions was to combine both registration and login into one single component that can be toggled between the two.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;div className=&amp;#39;auth-toggle&amp;#39;&amp;gt;&#xA;  &amp;lt;button className={!isLogin ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;} onClick={() =&amp;gt; setIsLogin(false)}&amp;gt;&#xA;    Register&#xA;  &amp;lt;/button&amp;gt;&#xA;  &amp;lt;button className={isLogin ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;} onClick={() =&amp;gt; setIsLogin(true)}&amp;gt;&#xA;    Login&#xA;  &amp;lt;/button&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This both reduced code duplication and provides a smoother UX, by not requiring navigation between separate pages for login and registration.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Error Handling (Registration)</title>
      <link>/posts/registration/</link>
      <pubDate>Mon, 23 Dec 2024 20:58:54 +0000</pubDate>
      <guid>/posts/registration/</guid>
      <description>&lt;h2 id=&#34;error-handling--feedback-for-users&#34;&gt;Error Handling + Feedback for Users&lt;/h2&gt;&#xA;&lt;p&gt;As is the standard for login/registration systems, we implemented error handling into this component.&#xA;The &lt;code&gt;react-toastify&lt;/code&gt; library was used to share error messages with the user. Our system maps Firebase&amp;rsquo;s error codes to more user-friendly messages.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch (error.code) {&#xA;  case &amp;#39;auth/user-not-found&amp;#39;:&#xA;    notify(&amp;#39;No account found with this email&amp;#39;);&#xA;    break;&#xA;  case &amp;#39;auth/wrong-password&amp;#39;:&#xA;    notify(&amp;#39;Incorrect password&amp;#39;);&#xA;    break;&#xA;  // ... more cases&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;what-to-take-from-this-all&#34;&gt;What to take from this all?&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We learned the significance of handling the initial loading state in UserContext.jsx. Without such, there would be a brief flash of the unauthenticated state, even for logged-in, authenticated users.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return (&#xA;  &amp;lt;UserContext.Provider value={{ user, setUser, loading }}&amp;gt;&#xA;    {!loading &amp;amp;&amp;amp; children}&#xA;  &amp;lt;/UserContext.Provider&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;We also found that centralized error handling greatly improved the user experience of our product.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
